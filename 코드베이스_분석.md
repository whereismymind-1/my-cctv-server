# my-cctv-server 코드베이스 심층 분석

## 📋 프로젝트 개요

**프로젝트명**: my-cctv-server  
**목적**: 라즈베리 파이 기반 실시간 CCTV 스트리밍 서버  
**주요 기술 스택**: 
- Node.js / Express.js
- MJPEG 스트리밍
- Three.js (3D 시각화)
- rpicam-vid (라즈베리 파이 카메라 제어)

## 🏗️ 프로젝트 구조

```
my-cctv-server/
├── server.js           # 메인 서버 파일 (활성)
├── fffServer.js        # FFmpeg 기반 서버 (비활성/주석처리)
├── package.json        # 프로젝트 의존성 관리
├── public/             # 정적 파일 디렉토리
│   ├── index.html      # 기본 스트리밍 뷰어
│   ├── three.html      # 3D 시각화 뷰어
│   ├── models/         # 3D 모델 파일
│   │   └── cube_with_screen.glb
│   └── textures/       # 텍스처 파일
│       └── background.hdr
└── node_modules/       # 노드 모듈
```

## 💻 핵심 구현 분석

### 1. server.js (메인 서버)

#### 주요 기능
- **동시 접속자 관리**: 최대 15명 제한
- **리소스 최적화**: 시청자가 없을 때 자동으로 카메라 프로세스 종료
- **MJPEG 스트리밍**: 실시간 비디오 스트림 브로드캐스팅

#### 핵심 로직 분석

##### 1.1 카메라 프로세스 관리
```javascript
// 카메라 시작 함수
function startCameraStream() {
  if (cameraProcess) return; // 중복 실행 방지
  
  const camArgs = [
    '-t', '0',           // 무제한 녹화
    '--codec', 'mjpeg',  // MJPEG 코덱 사용
    '--inline',          // 인라인 헤더
    '--width', '640',    
    '--height', '480',
    '--framerate', '20',
    '-o', '-'            // stdout으로 출력
  ];
  cameraProcess = spawn('rpicam-vid', camArgs);
}
```
- **장점**: 직접 MJPEG으로 인코딩하여 변환 오버헤드 최소화
- **개선점**: 해상도와 프레임레이트를 환경변수나 설정 파일로 관리 필요

##### 1.2 JPEG 프레임 파싱
```javascript
// SOI (Start of Image) & EOI (End of Image) 마커로 프레임 분리
const SOI = Buffer.from([0xff, 0xd8]);
const EOI = Buffer.from([0xff, 0xd9]);

// 버퍼에서 완전한 JPEG 프레임 추출
while (true) {
  const start = buffer.indexOf(SOI);
  if (start === -1) break;
  const end = buffer.indexOf(EOI, start + 2);
  if (end === -1) break;
  const frame = buffer.slice(start, end + 2);
  // 프레임 브로드캐스팅...
}
```
- **장점**: 효율적인 스트림 파싱으로 메모리 사용 최적화
- **개선점**: 버퍼 오버플로우 방지를 위한 최대 버퍼 크기 제한 필요

##### 1.3 클라이언트 관리
```javascript
const clients = new Set(); // 중복 방지를 위한 Set 사용
const MAX_CLIENTS = 15;

// 클라이언트 연결 시
if (clients.size >= MAX_CLIENTS) {
  res.status(503).send('Sorry, the broadcast is full.');
  return;
}
```
- **장점**: Set을 사용한 효율적인 클라이언트 관리
- **개선점**: 클라이언트별 메타데이터(IP, 연결시간 등) 추적 필요

### 2. fffServer.js (대체 구현 - 비활성)

H.264 → MJPEG 변환을 위해 FFmpeg를 사용하는 대체 구현
- **장점**: H.264의 효율적인 압축률 활용
- **단점**: FFmpeg 변환 과정에서 CPU 오버헤드 발생
- **상태**: 주석 처리되어 현재 사용하지 않음

### 3. 프론트엔드 구현

#### 3.1 index.html (기본 뷰어)
```html
<img src="/stream" alt="camera stream" />
```
- 단순한 이미지 태그로 MJPEG 스트림 표시
- 브라우저의 자동 MJPEG 파싱 기능 활용

#### 3.2 three.html (3D 뷰어)
- Three.js를 사용한 3D 환경에서 CCTV 스트림 표시
- GLB 모델 내의 스크린에 실시간 비디오 텍스처 매핑
- HDRI 배경 환경맵 적용으로 사실적인 렌더링

## 🔍 보안 및 성능 분석

### 보안 취약점
1. **인증/인가 부재**: 누구나 스트림에 접근 가능
2. **HTTPS 미지원**: 평문 통신으로 도청 가능
3. **IP 기반 접근 제어 없음**: 특정 IP만 허용하는 기능 부재
4. **DDoS 공격 취약**: Rate limiting 없음

### 성능 특성
1. **메모리 효율성**: 스트림 버퍼링으로 메모리 사용 최적화
2. **CPU 사용**: 직접 MJPEG 인코딩으로 변환 오버헤드 최소화
3. **네트워크 대역폭**: MJPEG의 높은 대역폭 사용 (압축률 낮음)
4. **확장성**: 단일 프로세스로 15명 제한

## 🚀 개선 방안

### 1. 보안 강화
```javascript
// 1.1 기본 인증 추가
const basicAuth = require('express-basic-auth');
app.use(basicAuth({
  users: { 'admin': 'strongpassword' },
  challenge: true
}));

// 1.2 HTTPS 적용
const https = require('https');
const fs = require('fs');
const options = {
  key: fs.readFileSync('key.pem'),
  cert: fs.readFileSync('cert.pem')
};
https.createServer(options, app).listen(443);

// 1.3 Rate Limiting 적용
const rateLimit = require('express-rate-limit');
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100 // 최대 요청 수
});
app.use('/stream', limiter);
```

### 2. 코드 구조 개선
```javascript
// 2.1 설정 파일 분리
// config.js
module.exports = {
  server: {
    port: process.env.PORT || 3000,
    maxClients: process.env.MAX_CLIENTS || 15
  },
  camera: {
    width: process.env.CAM_WIDTH || 640,
    height: process.env.CAM_HEIGHT || 480,
    framerate: process.env.CAM_FPS || 20,
    codec: 'mjpeg'
  },
  security: {
    enableAuth: process.env.ENABLE_AUTH === 'true',
    enableHttps: process.env.ENABLE_HTTPS === 'true'
  }
};

// 2.2 클래스 기반 구조로 리팩토링
class CameraManager {
  constructor(config) {
    this.config = config;
    this.process = null;
    this.clients = new Map(); // Set → Map으로 변경하여 메타데이터 저장
  }

  async start() {
    if (this.process) return;
    // 카메라 시작 로직
  }

  async stop() {
    if (!this.process) return;
    // 카메라 종료 로직
  }

  addClient(clientId, response, metadata) {
    if (this.clients.size >= this.config.maxClients) {
      throw new Error('Maximum clients reached');
    }
    this.clients.set(clientId, { response, metadata, connectedAt: Date.now() });
  }

  removeClient(clientId) {
    this.clients.delete(clientId);
    if (this.clients.size === 0) {
      setTimeout(() => this.stop(), 10000); // 10초 후 자동 종료
    }
  }
}
```

### 3. 에러 처리 강화
```javascript
// 3.1 전역 에러 핸들러
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  // 로깅 시스템에 기록
  // 필요시 graceful shutdown
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

// 3.2 스트림 에러 처리 개선
class StreamErrorHandler {
  static handleClientError(client, error) {
    console.error(`Client ${client.id} error:`, error);
    // 에러 통계 수집
    // 클라이언트 자동 정리
  }

  static handleCameraError(error) {
    console.error('Camera error:', error);
    // 카메라 재시작 시도
    // 알림 발송
  }
}
```

### 4. 모니터링 및 로깅
```javascript
// 4.1 Winston 로거 적용
const winston = require('winston');
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({ format: winston.format.simple() })
  ]
});

// 4.2 메트릭 수집
class Metrics {
  constructor() {
    this.stats = {
      totalConnections: 0,
      activeConnections: 0,
      totalBytesTransferred: 0,
      averageStreamDuration: 0,
      errors: []
    };
  }

  recordConnection() {
    this.stats.totalConnections++;
    this.stats.activeConnections++;
  }

  recordDisconnection(duration) {
    this.stats.activeConnections--;
    this.updateAverageDuration(duration);
  }

  getStats() {
    return { ...this.stats, timestamp: Date.now() };
  }
}

// 4.3 헬스체크 엔드포인트
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    uptime: process.uptime(),
    clients: clients.size,
    cameraActive: !!cameraProcess,
    memory: process.memoryUsage(),
    timestamp: Date.now()
  });
});
```

### 5. 성능 최적화
```javascript
// 5.1 적응형 품질 조정
class AdaptiveQuality {
  constructor() {
    this.qualities = [
      { width: 320, height: 240, fps: 10, quality: 50 },
      { width: 640, height: 480, fps: 15, quality: 70 },
      { width: 1280, height: 720, fps: 20, quality: 85 }
    ];
  }

  getOptimalQuality(clientCount, bandwidth) {
    // 클라이언트 수와 대역폭에 따라 품질 자동 조정
    if (clientCount > 10) return this.qualities[0];
    if (clientCount > 5) return this.qualities[1];
    return this.qualities[2];
  }
}

// 5.2 버퍼 풀 사용으로 메모리 할당 최적화
class BufferPool {
  constructor(size, bufferSize) {
    this.pool = [];
    this.bufferSize = bufferSize;
    for (let i = 0; i < size; i++) {
      this.pool.push(Buffer.alloc(bufferSize));
    }
  }

  acquire() {
    return this.pool.pop() || Buffer.alloc(this.bufferSize);
  }

  release(buffer) {
    if (buffer.length === this.bufferSize) {
      buffer.fill(0); // 버퍼 초기화
      this.pool.push(buffer);
    }
  }
}
```

### 6. 기능 확장
```javascript
// 6.1 녹화 기능 추가
class Recorder {
  constructor(outputPath) {
    this.outputPath = outputPath;
    this.recording = false;
    this.fileStream = null;
  }

  start() {
    if (this.recording) return;
    const filename = `recording_${Date.now()}.mjpeg`;
    this.fileStream = fs.createWriteStream(path.join(this.outputPath, filename));
    this.recording = true;
  }

  write(frame) {
    if (this.recording && this.fileStream) {
      this.fileStream.write(frame);
    }
  }

  stop() {
    if (!this.recording) return;
    this.fileStream.end();
    this.recording = false;
  }
}

// 6.2 모션 감지 기능
class MotionDetector {
  constructor(threshold = 0.1) {
    this.threshold = threshold;
    this.previousFrame = null;
  }

  detect(currentFrame) {
    if (!this.previousFrame) {
      this.previousFrame = currentFrame;
      return false;
    }

    // 간단한 픽셀 차이 기반 모션 감지
    const diff = this.calculateDifference(this.previousFrame, currentFrame);
    this.previousFrame = currentFrame;
    
    return diff > this.threshold;
  }

  calculateDifference(frame1, frame2) {
    // 프레임 간 차이 계산 로직
    // 실제 구현에서는 이미지 처리 라이브러리 사용 권장
  }
}

// 6.3 웹소켓 지원 추가
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  ws.on('message', (message) => {
    // 제어 명령 처리 (줌, 팬, 틸트 등)
    const command = JSON.parse(message);
    handleCameraControl(command);
  });

  // 프레임을 웹소켓으로도 전송
  ws.send(JSON.stringify({ type: 'frame', data: frameData }));
});
```

### 7. 테스트 추가
```javascript
// 7.1 단위 테스트 (Jest 사용)
// __tests__/cameraManager.test.js
describe('CameraManager', () => {
  let cameraManager;

  beforeEach(() => {
    cameraManager = new CameraManager(mockConfig);
  });

  test('should start camera process', async () => {
    await cameraManager.start();
    expect(cameraManager.process).toBeTruthy();
  });

  test('should reject when max clients reached', () => {
    for (let i = 0; i < MAX_CLIENTS; i++) {
      cameraManager.addClient(`client_${i}`, mockResponse, {});
    }
    
    expect(() => {
      cameraManager.addClient('overflow', mockResponse, {});
    }).toThrow('Maximum clients reached');
  });
});

// 7.2 통합 테스트
// __tests__/integration.test.js
describe('Stream Endpoint', () => {
  test('should return 503 when max clients reached', async () => {
    // MAX_CLIENTS만큼 연결 생성
    const connections = [];
    for (let i = 0; i < MAX_CLIENTS; i++) {
      connections.push(request(app).get('/stream'));
    }

    // 추가 연결 시도
    const response = await request(app).get('/stream');
    expect(response.status).toBe(503);
  });
});
```

### 8. 배포 및 운영
```yaml
# 8.1 Docker 컨테이너화
# Dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["node", "server.js"]

# 8.2 Docker Compose 설정
# docker-compose.yml
version: '3.8'
services:
  cctv-server:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - MAX_CLIENTS=20
      - CAM_WIDTH=1280
      - CAM_HEIGHT=720
    devices:
      - /dev/video0:/dev/video0
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### 9. 문서화
```javascript
// 9.1 API 문서화 (Swagger 사용)
const swaggerJsDoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'CCTV Server API',
      version: '1.0.0',
      description: 'Raspberry Pi CCTV Streaming Server API'
    }
  },
  apis: ['./server.js']
};

/**
 * @swagger
 * /stream:
 *   get:
 *     summary: Get MJPEG video stream
 *     responses:
 *       200:
 *         description: MJPEG stream
 *         content:
 *           multipart/x-mixed-replace:
 *             schema:
 *               type: string
 *               format: binary
 *       503:
 *         description: Maximum clients reached
 */

const specs = swaggerJsDoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));
```

## 📊 성능 벤치마크 제안

### 측정 항목
1. **지연시간 (Latency)**: 카메라 캡처 → 클라이언트 표시
2. **처리량 (Throughput)**: 초당 전송 프레임 수
3. **CPU 사용률**: 클라이언트 수별 CPU 사용량
4. **메모리 사용량**: 시간대별 메모리 사용 패턴
5. **네트워크 대역폭**: 클라이언트당 평균 대역폭

### 테스트 시나리오
1. **부하 테스트**: 1-15명 동시 접속 시 성능 측정
2. **장시간 테스트**: 24시간 연속 스트리밍 안정성
3. **네트워크 장애 테스트**: 패킷 손실, 지연 상황 대응
4. **리소스 제한 테스트**: CPU/메모리 제한 상황 동작

## 🎯 우선순위별 개선 로드맵

### Phase 1 (즉시 적용 권장)
1. ✅ 기본 인증 추가
2. ✅ 에러 처리 강화
3. ✅ 로깅 시스템 구축
4. ✅ 설정 파일 분리

### Phase 2 (단기 - 1-2주)
1. 📋 HTTPS 적용
2. 📋 Rate Limiting
3. 📋 헬스체크 엔드포인트
4. 📋 기본 테스트 추가

### Phase 3 (중기 - 1개월)
1. 📋 클래스 기반 리팩토링
2. 📋 웹소켓 지원
3. 📋 적응형 품질 조정
4. 📋 Docker 컨테이너화

### Phase 4 (장기 - 2-3개월)
1. 📋 녹화 기능
2. 📋 모션 감지
3. 📋 다중 카메라 지원
4. 📋 클라우드 저장소 연동

## 💡 결론

현재 코드베이스는 기본적인 CCTV 스트리밍 기능을 잘 구현하고 있으며, 특히 리소스 관리와 스트림 파싱 부분이 효율적으로 작성되어 있습니다. 

### 강점
- 간결하고 이해하기 쉬운 코드 구조
- 효율적인 버퍼 관리와 스트림 파싱
- 자동 리소스 정리 메커니즘

### 개선 필요 영역
- 보안 기능 전무 (인증, 암호화, 접근 제어)
- 에러 처리 및 로깅 부족
- 확장성 제한 (단일 프로세스, 하드코딩된 설정)
- 테스트 코드 부재

제안된 개선 방안을 단계적으로 적용하면, 프로덕션 환경에서도 안정적으로 운영 가능한 전문적인 CCTV 시스템으로 발전시킬 수 있을 것입니다.

## 📚 참고 자료

- [Node.js Best Practices](https://github.com/goldbergyoni/nodebestpractices)
- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)
- [MJPEG Streaming Protocol](https://en.wikipedia.org/wiki/Motion_JPEG)
- [Raspberry Pi Camera Documentation](https://www.raspberrypi.com/documentation/accessories/camera.html)
- [Three.js Documentation](https://threejs.org/docs/)

---

*분석 일자: 2025년 9월 6일*  
*작성자: Claude Code Assistant*