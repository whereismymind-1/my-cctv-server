# ğŸ›ï¸ ì†Œí”„íŠ¸ì›¨ì–´ ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜

## ğŸ“Œ ê°œìš”

ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ëŠ” ê´€ì‹¬ì‚¬ë¥¼ ë¶„ë¦¬í•˜ê³  ì˜ì¡´ì„±ì„ ê´€ë¦¬í•˜ì—¬ ìœ ì§€ë³´ìˆ˜ê°€ ì‰¬ìš´ ì‹œìŠ¤í…œì„ ë§Œë“­ë‹ˆë‹¤.

### í•µì‹¬ ì›ì¹™
1. **ë‹¨ë°©í–¥ ì˜ì¡´ì„±**: ìƒìœ„ ë ˆì´ì–´ëŠ” í•˜ìœ„ ë ˆì´ì–´ì—ë§Œ ì˜ì¡´
2. **ê´€ì‹¬ì‚¬ ë¶„ë¦¬**: ê° ë ˆì´ì–´ëŠ” ëª…í™•í•œ ì±…ì„ì„ ê°€ì§
3. **í…ŒìŠ¤íŠ¸ ìš©ì´ì„±**: ê° ë ˆì´ì–´ë¥¼ ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
4. **í™•ì¥ì„±**: ë ˆì´ì–´ë³„ë¡œ ë…ë¦½ì  í™•ì¥ ê°€ëŠ¥

### ë ˆì´ì–´ êµ¬ì¡°
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Presentation Layer (í‘œí˜„ ê³„ì¸µ)     â”‚ â† ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Application Layer (ì‘ìš© ê³„ì¸µ)      â”‚ â† ë¹„ì¦ˆë‹ˆìŠ¤ ì›Œí¬í”Œë¡œìš°
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Domain Layer (ë„ë©”ì¸ ê³„ì¸µ)       â”‚ â† í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Infrastructure Layer (ì¸í”„ë¼ ê³„ì¸µ)  â”‚ â† ì™¸ë¶€ ì‹œìŠ¤í…œ ì—°ë™
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¨ Frontend ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ (React + TypeScript)

### 1. Presentation Layer (UI ê³„ì¸µ)
> **ì±…ì„**: ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤, ì‹œê°ì  í‘œí˜„

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- React ì»´í¬ë„ŒíŠ¸ (UIë§Œ ë‹´ë‹¹)
- ìŠ¤íƒ€ì¼ (CSS/Tailwind)
- ì• ë‹ˆë©”ì´ì…˜
- ë ˆì´ì•„ì›ƒ

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
frontend/src/
â”œâ”€â”€ components/          # í”„ë ˆì  í…Œì´ì…˜ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ common/         # ê³µí†µ UI ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”‚   â””â”€â”€ Modal.tsx
â”‚   â”œâ”€â”€ stream/         # ìŠ¤íŠ¸ë¦¼ ê´€ë ¨ UI
â”‚   â”‚   â”œâ”€â”€ VideoPlayer.tsx
â”‚   â”‚   â”œâ”€â”€ StreamInfo.tsx
â”‚   â”‚   â””â”€â”€ ViewerCount.tsx
â”‚   â””â”€â”€ comment/        # ëŒ“ê¸€ ê´€ë ¨ UI
â”‚       â”œâ”€â”€ CommentCanvas.tsx
â”‚       â”œâ”€â”€ CommentInput.tsx
â”‚       â””â”€â”€ CommentList.tsx
â”œâ”€â”€ layouts/            # ë ˆì´ì•„ì›ƒ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ MainLayout.tsx
â”‚   â””â”€â”€ StreamLayout.tsx
â””â”€â”€ styles/            # ìŠ¤íƒ€ì¼ íŒŒì¼
    â”œâ”€â”€ globals.css
    â””â”€â”€ tailwind.css
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// components/comment/CommentInput.tsx
import React from 'react';

interface CommentInputProps {
  onSubmit: (text: string, command: string) => void;
  disabled?: boolean;
  placeholder?: string;
}

// ìˆœìˆ˜í•œ UI ì»´í¬ë„ŒíŠ¸ - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì—†ìŒ
export const CommentInput: React.FC<CommentInputProps> = ({
  onSubmit,
  disabled = false,
  placeholder = "ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..."
}) => {
  const [text, setText] = React.useState('');
  const [command, setCommand] = React.useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (text.trim()) {
      onSubmit(text, command);
      setText('');
      setCommand('');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="flex gap-2">
      <input
        type="text"
        value={command}
        onChange={(e) => setCommand(e.target.value)}
        placeholder="ëª…ë ¹ì–´ (ì˜ˆ: ue red)"
        className="px-3 py-2 border rounded"
        disabled={disabled}
      />
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder={placeholder}
        className="flex-1 px-3 py-2 border rounded"
        disabled={disabled}
      />
      <button
        type="submit"
        disabled={disabled || !text.trim()}
        className="px-4 py-2 bg-blue-500 text-white rounded"
      >
        ì „ì†¡
      </button>
    </form>
  );
};
```

### 2. Application Layer (ì‘ìš© ê³„ì¸µ)
> **ì±…ì„**: ë¹„ì¦ˆë‹ˆìŠ¤ ì›Œí¬í”Œë¡œìš°, ìƒíƒœ ê´€ë¦¬, ìœ ì¦ˆì¼€ì´ìŠ¤ ì¡°ì •

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- Custom Hooks (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
- ìƒíƒœ ê´€ë¦¬ (Zustand Stores)
- ì„œë¹„ìŠ¤ ë ˆì´ì–´
- ìœ íš¨ì„± ê²€ì¦

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
frontend/src/
â”œâ”€â”€ hooks/              # ì»¤ìŠ¤í…€ í›… (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
â”‚   â”œâ”€â”€ useStream.ts
â”‚   â”œâ”€â”€ useComment.ts
â”‚   â”œâ”€â”€ useWebSocket.ts
â”‚   â””â”€â”€ useAuth.ts
â”œâ”€â”€ stores/             # ìƒíƒœ ê´€ë¦¬ (Zustand)
â”‚   â”œâ”€â”€ authStore.ts
â”‚   â”œâ”€â”€ streamStore.ts
â”‚   â””â”€â”€ commentStore.ts
â”œâ”€â”€ services/           # ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ CommentService.ts
â”‚   â”œâ”€â”€ StreamService.ts
â”‚   â””â”€â”€ AuthService.ts
â””â”€â”€ validators/         # ìœ íš¨ì„± ê²€ì¦
    â”œâ”€â”€ commentValidator.ts
    â””â”€â”€ streamValidator.ts
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// hooks/useComment.ts
import { useCallback } from 'react';
import { useCommentStore } from '@/stores/commentStore';
import { useWebSocket } from './useWebSocket';
import { CommentService } from '@/services/CommentService';
import { Comment } from '@/domain/models/Comment';

export const useComment = (streamId: string) => {
  const { comments, addComment, removeComment } = useCommentStore();
  const { socket, isConnected } = useWebSocket();
  const commentService = new CommentService();

  // ëŒ“ê¸€ ì „ì†¡ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  const sendComment = useCallback(async (text: string, command?: string) => {
    try {
      // 1. ìœ íš¨ì„± ê²€ì¦
      const validatedComment = await commentService.validate(text, command);
      
      // 2. ëª…ë ¹ì–´ íŒŒì‹±
      const style = commentService.parseCommand(command);
      
      // 3. ëŒ“ê¸€ ê°ì²´ ìƒì„±
      const comment = new Comment({
        text: validatedComment.text,
        style,
        streamId
      });
      
      // 4. WebSocketìœ¼ë¡œ ì „ì†¡
      socket?.emit('send_comment', comment.toDTO());
      
      // 5. ë‚™ê´€ì  ì—…ë°ì´íŠ¸
      addComment(comment);
      
      return { success: true };
    } catch (error) {
      console.error('Failed to send comment:', error);
      return { success: false, error };
    }
  }, [streamId, socket, commentService, addComment]);

  // WebSocket ì´ë²¤íŠ¸ êµ¬ë…
  React.useEffect(() => {
    if (!socket) return;

    socket.on('new_comment', (data) => {
      const comment = Comment.fromDTO(data);
      addComment(comment);
    });

    socket.on('comment_deleted', (commentId) => {
      removeComment(commentId);
    });

    return () => {
      socket.off('new_comment');
      socket.off('comment_deleted');
    };
  }, [socket, addComment, removeComment]);

  return {
    comments,
    sendComment,
    isConnected
  };
};
```

```typescript
// stores/commentStore.ts
import { create } from 'zustand';
import { Comment } from '@/domain/models/Comment';

interface CommentStore {
  comments: Comment[];
  activeComments: Comment[];
  
  addComment: (comment: Comment) => void;
  removeComment: (commentId: string) => void;
  updateCommentPosition: (commentId: string, position: Position) => void;
  clearOldComments: () => void;
}

export const useCommentStore = create<CommentStore>((set, get) => ({
  comments: [],
  activeComments: [],
  
  addComment: (comment) => {
    set(state => ({
      comments: [...state.comments, comment],
      activeComments: [...state.activeComments, comment]
    }));
    
    // 5ì´ˆ í›„ í™œì„± ëŒ“ê¸€ì—ì„œ ì œê±°
    setTimeout(() => {
      set(state => ({
        activeComments: state.activeComments.filter(c => c.id !== comment.id)
      }));
    }, 5000);
  },
  
  removeComment: (commentId) => {
    set(state => ({
      comments: state.comments.filter(c => c.id !== commentId),
      activeComments: state.activeComments.filter(c => c.id !== commentId)
    }));
  },
  
  updateCommentPosition: (commentId, position) => {
    set(state => ({
      activeComments: state.activeComments.map(c =>
        c.id === commentId ? { ...c, position } : c
      )
    }));
  },
  
  clearOldComments: () => {
    const now = Date.now();
    set(state => ({
      comments: state.comments.filter(c => now - c.timestamp < 300000) // 5ë¶„
    }));
  }
}));
```

### 3. Domain Layer (ë„ë©”ì¸ ê³„ì¸µ)
> **ì±…ì„**: í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§, ë„ë©”ì¸ ëª¨ë¸, ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- ë„ë©”ì¸ ëª¨ë¸/ì—”í‹°í‹°
- ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
- ë„ë©”ì¸ ì„œë¹„ìŠ¤
- ê°’ ê°ì²´

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
frontend/src/domain/
â”œâ”€â”€ models/             # ë„ë©”ì¸ ëª¨ë¸
â”‚   â”œâ”€â”€ Comment.ts
â”‚   â”œâ”€â”€ Stream.ts
â”‚   â”œâ”€â”€ User.ts
â”‚   â””â”€â”€ Room.ts
â”œâ”€â”€ valueObjects/       # ê°’ ê°ì²´
â”‚   â”œâ”€â”€ CommentStyle.ts
â”‚   â”œâ”€â”€ CommentPosition.ts
â”‚   â””â”€â”€ StreamStatus.ts
â”œâ”€â”€ services/           # ë„ë©”ì¸ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ CommentParser.ts
â”‚   â”œâ”€â”€ LaneCalculator.ts
â”‚   â””â”€â”€ CollisionDetector.ts
â””â”€â”€ rules/             # ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
    â”œâ”€â”€ CommentRules.ts
    â””â”€â”€ StreamRules.ts
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// domain/models/Comment.ts
import { CommentStyle } from '../valueObjects/CommentStyle';
import { CommentPosition } from '../valueObjects/CommentPosition';

export class Comment {
  public readonly id: string;
  public readonly text: string;
  public readonly userId: string;
  public readonly streamId: string;
  public readonly style: CommentStyle;
  public position: CommentPosition;
  public readonly timestamp: number;
  public readonly duration: number;

  constructor(params: {
    text: string;
    userId?: string;
    streamId: string;
    style?: Partial<CommentStyle>;
    command?: string;
  }) {
    // ë„ë©”ì¸ ê·œì¹™ ì ìš©
    this.id = this.generateId();
    this.text = this.sanitizeText(params.text);
    this.userId = params.userId || 'anonymous';
    this.streamId = params.streamId;
    this.style = new CommentStyle(params.style);
    this.position = new CommentPosition();
    this.timestamp = Date.now();
    this.duration = this.calculateDuration();
    
    // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
    this.validate();
  }

  private sanitizeText(text: string): string {
    // XSS ë°©ì§€, ê¸¸ì´ ì œí•œ ë“±
    return text
      .replace(/<[^>]*>/g, '')
      .trim()
      .slice(0, 200);
  }

  private calculateDuration(): number {
    // í…ìŠ¤íŠ¸ ê¸¸ì´ì™€ ìŠ¤íƒ€ì¼ì— ë”°ë¥¸ í‘œì‹œ ì‹œê°„ ê³„ì‚°
    const baseTime = 4000;
    const charTime = this.text.length * 50;
    return Math.min(baseTime + charTime, 8000);
  }

  private validate(): void {
    if (!this.text || this.text.length === 0) {
      throw new Error('Comment text cannot be empty');
    }
    if (this.text.length > 200) {
      throw new Error('Comment text too long');
    }
  }

  // ì¶©ëŒ ê²€ì‚¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  public checkCollision(other: Comment): boolean {
    if (this.position.lane !== other.position.lane) {
      return false;
    }
    
    const thisEnd = this.timestamp + this.duration;
    const otherEnd = other.timestamp + other.duration;
    
    return !(thisEnd < other.timestamp || this.timestamp > otherEnd);
  }

  public toDTO() {
    return {
      id: this.id,
      text: this.text,
      userId: this.userId,
      streamId: this.streamId,
      style: this.style.toDTO(),
      position: this.position.toDTO(),
      timestamp: this.timestamp,
      duration: this.duration
    };
  }

  public static fromDTO(dto: any): Comment {
    const comment = Object.create(Comment.prototype);
    return Object.assign(comment, dto);
  }

  private generateId(): string {
    return `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

```typescript
// domain/services/LaneCalculator.ts
import { Comment } from '../models/Comment';
import { CommentPosition } from '../valueObjects/CommentPosition';

export class LaneCalculator {
  private readonly laneCount: number = 12;
  private readonly laneHeight: number = 30;
  private readonly canvasWidth: number = 1280;
  private readonly canvasHeight: number = 720;
  private lanes: Map<number, Comment[]> = new Map();

  constructor() {
    // ë ˆì¸ ì´ˆê¸°í™”
    for (let i = 0; i < this.laneCount; i++) {
      this.lanes.set(i, []);
    }
  }

  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§: ìµœì  ë ˆì¸ ì°¾ê¸°
  public assignLane(comment: Comment): number {
    // ê³ ì • ëŒ“ê¸€ ì²˜ë¦¬
    if (comment.style.position === 'top') {
      return 0;
    }
    if (comment.style.position === 'bottom') {
      return this.laneCount - 1;
    }

    // ìœ ë™ ëŒ“ê¸€: ì¶©ëŒ ì—†ëŠ” ë ˆì¸ ì°¾ê¸°
    for (let i = 0; i < this.laneCount; i++) {
      if (!this.hasCollisionInLane(comment, i)) {
        this.lanes.get(i)?.push(comment);
        this.cleanOldComments(i);
        return i;
      }
    }

    // ëª¨ë“  ë ˆì¸ì´ ì°¨ìˆìœ¼ë©´ ê°€ì¥ ë¹ˆ ë ˆì¸ ì„ íƒ
    return this.findLeastCrowdedLane();
  }

  private hasCollisionInLane(newComment: Comment, laneIndex: number): boolean {
    const laneComments = this.lanes.get(laneIndex) || [];
    
    for (const existing of laneComments) {
      if (this.detectCollision(newComment, existing)) {
        return true;
      }
    }
    
    return false;
  }

  private detectCollision(c1: Comment, c2: Comment): boolean {
    // ì‹œê°„ ê¸°ë°˜ ì¶©ëŒ ê²€ì‚¬
    const c1End = c1.timestamp + c1.duration;
    const c2End = c2.timestamp + c2.duration;
    
    if (c1End < c2.timestamp || c1.timestamp > c2End) {
      return false;
    }
    
    // ìœ„ì¹˜ ê¸°ë°˜ ì¶©ëŒ ê²€ì‚¬
    const c1Speed = this.canvasWidth / c1.duration;
    const c2Speed = this.canvasWidth / c2.duration;
    
    // ë” ë³µì¡í•œ ì¶©ëŒ ê²€ì‚¬ ë¡œì§...
    return true;
  }

  private findLeastCrowdedLane(): number {
    let minCount = Infinity;
    let bestLane = 0;
    
    this.lanes.forEach((comments, lane) => {
      if (comments.length < minCount) {
        minCount = comments.length;
        bestLane = lane;
      }
    });
    
    return bestLane;
  }

  private cleanOldComments(laneIndex: number): void {
    const now = Date.now();
    const laneComments = this.lanes.get(laneIndex) || [];
    
    this.lanes.set(
      laneIndex,
      laneComments.filter(c => now - c.timestamp < c.duration + 1000)
    );
  }
}
```

### 4. Infrastructure Layer (ì¸í”„ë¼ ê³„ì¸µ)
> **ì±…ì„**: ì™¸ë¶€ ì‹œìŠ¤í…œê³¼ì˜ í†µì‹ , ê¸°ìˆ ì  êµ¬í˜„ ì„¸ë¶€ì‚¬í•­

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- API í´ë¼ì´ì–¸íŠ¸
- WebSocket ì—°ê²°
- ë¡œì»¬ ìŠ¤í† ë¦¬ì§€
- ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë˜í¼

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
frontend/src/infrastructure/
â”œâ”€â”€ api/                # API í†µì‹ 
â”‚   â”œâ”€â”€ client.ts      # Axios ì¸ìŠ¤í„´ìŠ¤
â”‚   â”œâ”€â”€ authApi.ts
â”‚   â”œâ”€â”€ streamApi.ts
â”‚   â””â”€â”€ commentApi.ts
â”œâ”€â”€ websocket/          # WebSocket
â”‚   â”œâ”€â”€ SocketClient.ts
â”‚   â””â”€â”€ SocketManager.ts
â”œâ”€â”€ storage/            # ë¡œì»¬ ìŠ¤í† ë¦¬ì§€
â”‚   â”œâ”€â”€ LocalStorage.ts
â”‚   â””â”€â”€ SessionStorage.ts
â”œâ”€â”€ canvas/             # Canvas ë Œë”ë§
â”‚   â”œâ”€â”€ CanvasRenderer.ts
â”‚   â””â”€â”€ CommentAnimator.ts
â””â”€â”€ external/           # ì™¸ë¶€ ì„œë¹„ìŠ¤
    â””â”€â”€ VideoPlayer.ts
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// infrastructure/websocket/SocketManager.ts
import { io, Socket } from 'socket.io-client';

export class SocketManager {
  private socket: Socket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private listeners: Map<string, Function[]> = new Map();

  public connect(url: string, token: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.socket = io(url, {
        auth: { token },
        transports: ['websocket'],
        reconnection: true,
        reconnectionAttempts: this.maxReconnectAttempts,
        reconnectionDelay: 1000,
      });

      this.socket.on('connect', () => {
        console.log('WebSocket connected');
        this.reconnectAttempts = 0;
        resolve();
      });

      this.socket.on('connect_error', (error) => {
        console.error('WebSocket connection error:', error);
        reject(error);
      });

      this.socket.on('disconnect', (reason) => {
        console.log('WebSocket disconnected:', reason);
        if (reason === 'io server disconnect') {
          // ì„œë²„ê°€ ì—°ê²°ì„ ëŠì€ ê²½ìš° ì¬ì—°ê²° ì‹œë„
          this.socket?.connect();
        }
      });
    });
  }

  public emit(event: string, data: any): void {
    if (!this.socket?.connected) {
      console.warn('Socket not connected');
      return;
    }
    this.socket.emit(event, data);
  }

  public on(event: string, handler: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)?.push(handler);
    this.socket?.on(event, handler);
  }

  public off(event: string, handler?: Function): void {
    if (handler) {
      this.socket?.off(event, handler);
      const handlers = this.listeners.get(event) || [];
      this.listeners.set(
        event,
        handlers.filter(h => h !== handler)
      );
    } else {
      this.socket?.off(event);
      this.listeners.delete(event);
    }
  }

  public disconnect(): void {
    this.socket?.disconnect();
    this.socket = null;
    this.listeners.clear();
  }

  public get isConnected(): boolean {
    return this.socket?.connected || false;
  }
}
```

```typescript
// infrastructure/api/streamApi.ts
import { apiClient } from './client';
import { Stream } from '@/domain/models/Stream';

export class StreamApi {
  private readonly baseUrl = '/api/streams';

  async getStreams(params?: {
    status?: string;
    page?: number;
    limit?: number;
  }): Promise<Stream[]> {
    const response = await apiClient.get(this.baseUrl, { params });
    return response.data.streams.map((dto: any) => Stream.fromDTO(dto));
  }

  async getStream(id: string): Promise<Stream> {
    const response = await apiClient.get(`${this.baseUrl}/${id}`);
    return Stream.fromDTO(response.data);
  }

  async createStream(data: {
    title: string;
    description?: string;
  }): Promise<Stream> {
    const response = await apiClient.post(this.baseUrl, data);
    return Stream.fromDTO(response.data);
  }

  async startStream(id: string): Promise<void> {
    await apiClient.post(`${this.baseUrl}/${id}/start`);
  }

  async endStream(id: string): Promise<void> {
    await apiClient.post(`${this.baseUrl}/${id}/end`);
  }
}
```

---

## ğŸš€ Backend ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ (NestJS + TypeScript)

### 1. Presentation Layer (í‘œí˜„ ê³„ì¸µ)
> **ì±…ì„**: HTTP/WebSocket ìš”ì²­ ì²˜ë¦¬, DTO ë³€í™˜, ì‘ë‹µ í¬ë§·íŒ…

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- Controllers (REST API)
- Gateways (WebSocket)
- DTOs (Data Transfer Objects)
- ìš”ì²­/ì‘ë‹µ ë³€í™˜

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
backend/src/
â”œâ”€â”€ controllers/        # REST API ì»¨íŠ¸ë¡¤ëŸ¬
â”‚   â”œâ”€â”€ auth.controller.ts
â”‚   â”œâ”€â”€ stream.controller.ts
â”‚   â””â”€â”€ user.controller.ts
â”œâ”€â”€ gateways/          # WebSocket ê²Œì´íŠ¸ì›¨ì´
â”‚   â”œâ”€â”€ comment.gateway.ts
â”‚   â””â”€â”€ stream.gateway.ts
â”œâ”€â”€ dto/               # DTO ì •ì˜
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ login.dto.ts
â”‚   â”‚   â””â”€â”€ register.dto.ts
â”‚   â”œâ”€â”€ stream/
â”‚   â”‚   â”œâ”€â”€ create-stream.dto.ts
â”‚   â”‚   â””â”€â”€ update-stream.dto.ts
â”‚   â””â”€â”€ comment/
â”‚       â””â”€â”€ send-comment.dto.ts
â””â”€â”€ pipes/             # ìœ íš¨ì„± ê²€ì¦ íŒŒì´í”„
    â””â”€â”€ validation.pipe.ts
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// controllers/stream.controller.ts
import { Controller, Get, Post, Body, Param, UseGuards, Query } from '@nestjs/common';
import { StreamService } from '@/application/services/stream.service';
import { CreateStreamDto } from '@/dto/stream/create-stream.dto';
import { JwtAuthGuard } from '@/guards/jwt-auth.guard';
import { CurrentUser } from '@/decorators/current-user.decorator';

@Controller('api/streams')
export class StreamController {
  constructor(private readonly streamService: StreamService) {}

  @Get()
  async getStreams(
    @Query('status') status?: string,
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 20,
  ) {
    // Presentation ì±…ì„: ìš”ì²­ íŒŒë¼ë¯¸í„° ë°›ê¸°, ì‘ë‹µ í¬ë§·íŒ…
    const streams = await this.streamService.findAll({ status, page, limit });
    
    return {
      streams: streams.map(s => s.toDTO()),
      total: streams.length,
      page,
      limit,
    };
  }

  @Get(':id')
  async getStream(@Param('id') id: string) {
    const stream = await this.streamService.findById(id);
    return stream.toDTO();
  }

  @Post()
  @UseGuards(JwtAuthGuard)
  async createStream(
    @Body() dto: CreateStreamDto,
    @CurrentUser() user: any,
  ) {
    // DTOë¥¼ ë„ë©”ì¸ ëª¨ë¸ë¡œ ë³€í™˜ì€ ì„œë¹„ìŠ¤ ë ˆì´ì–´ì—ì„œ
    const stream = await this.streamService.create(dto, user.id);
    return stream.toDTO();
  }

  @Post(':id/start')
  @UseGuards(JwtAuthGuard)
  async startStream(
    @Param('id') id: string,
    @CurrentUser() user: any,
  ) {
    await this.streamService.start(id, user.id);
    return { status: 'live', startedAt: new Date() };
  }
}
```

```typescript
// gateways/comment.gateway.ts
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { CommentService } from '@/application/services/comment.service';
import { SendCommentDto } from '@/dto/comment/send-comment.dto';

@WebSocketGateway({
  cors: { origin: '*' },
  namespace: 'comments',
})
export class CommentGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  constructor(private readonly commentService: CommentService) {}

  async handleConnection(client: Socket) {
    // ì¸ì¦ í™•ì¸
    const token = client.handshake.auth.token;
    const user = await this.validateToken(token);
    
    if (!user) {
      client.disconnect();
      return;
    }
    
    client.data.user = user;
    console.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    console.log(`Client disconnected: ${client.id}`);
    // ì •ë¦¬ ì‘ì—…
    this.commentService.handleDisconnect(client.id);
  }

  @SubscribeMessage('join_room')
  async handleJoinRoom(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { streamId: string },
  ) {
    await client.join(data.streamId);
    const viewerCount = await this.commentService.addViewer(data.streamId, client.data.user.id);
    
    // ë£¸ì˜ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì•Œë¦¼
    this.server.to(data.streamId).emit('viewer_count', { 
      streamId: data.streamId,
      count: viewerCount 
    });
    
    return { joined: true, streamId: data.streamId };
  }

  @SubscribeMessage('send_comment')
  async handleComment(
    @ConnectedSocket() client: Socket,
    @MessageBody() dto: SendCommentDto,
  ) {
    try {
      // Application Layerë¡œ ìœ„ì„
      const comment = await this.commentService.processComment(
        dto,
        client.data.user,
      );
      
      // ë£¸ì˜ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      this.server.to(dto.streamId).emit('new_comment', comment.toDTO());
      
      return { success: true, commentId: comment.id };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async validateToken(token: string): Promise<any> {
    // JWT ê²€ì¦ ë¡œì§
    return null;
  }
}
```

### 2. Application Layer (ì‘ìš© ê³„ì¸µ)
> **ì±…ì„**: ìœ ì¦ˆì¼€ì´ìŠ¤ êµ¬í˜„, íŠ¸ëœì­ì…˜ ê´€ë¦¬, ì›Œí¬í”Œë¡œìš° ì¡°ì •

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- Application Services
- Use Cases
- íŠ¸ëœì­ì…˜ ìŠ¤í¬ë¦½íŠ¸
- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
backend/src/application/
â”œâ”€â”€ services/           # ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â”œâ”€â”€ stream.service.ts
â”‚   â”œâ”€â”€ comment.service.ts
â”‚   â””â”€â”€ user.service.ts
â”œâ”€â”€ usecases/          # ìœ ì¦ˆì¼€ì´ìŠ¤
â”‚   â”œâ”€â”€ SendCommentUseCase.ts
â”‚   â”œâ”€â”€ CreateStreamUseCase.ts
â”‚   â””â”€â”€ StartStreamUseCase.ts
â”œâ”€â”€ events/            # ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
â”‚   â”œâ”€â”€ StreamEventHandler.ts
â”‚   â””â”€â”€ CommentEventHandler.ts
â””â”€â”€ interfaces/        # ì¸í„°í˜ì´ìŠ¤
    â”œâ”€â”€ IStreamRepository.ts
    â””â”€â”€ ICommentRepository.ts
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// application/services/comment.service.ts
import { Injectable } from '@nestjs/common';
import { Comment } from '@/domain/entities/Comment';
import { LaneManager } from '@/domain/services/LaneManager';
import { CommentValidator } from '@/domain/services/CommentValidator';
import { ICommentRepository } from '../interfaces/ICommentRepository';
import { IStreamRepository } from '../interfaces/IStreamRepository';
import { RedisService } from '@/infrastructure/redis/redis.service';

@Injectable()
export class CommentService {
  constructor(
    private readonly commentRepository: ICommentRepository,
    private readonly streamRepository: IStreamRepository,
    private readonly laneManager: LaneManager,
    private readonly validator: CommentValidator,
    private readonly redis: RedisService,
  ) {}

  async processComment(dto: any, user: any): Promise<Comment> {
    // 1. ìŠ¤íŠ¸ë¦¼ ì¡´ì¬ í™•ì¸
    const stream = await this.streamRepository.findById(dto.streamId);
    if (!stream || !stream.isLive()) {
      throw new Error('Stream is not live');
    }

    // 2. Rate Limiting ì²´í¬
    const canSend = await this.checkRateLimit(user.id, dto.streamId);
    if (!canSend) {
      throw new Error('Too many comments. Please wait.');
    }

    // 3. ëŒ“ê¸€ ìœ íš¨ì„± ê²€ì¦
    const validatedText = await this.validator.validate(dto.text);

    // 4. ë„ë©”ì¸ ëª¨ë¸ ìƒì„±
    const comment = new Comment({
      text: validatedText,
      userId: user.id,
      streamId: dto.streamId,
      command: dto.command,
    });

    // 5. ë ˆì¸ í• ë‹¹
    const lane = await this.laneManager.assignLane(comment);
    comment.setLane(lane);

    // 6. ìœ„ì¹˜ ê³„ì‚°
    comment.calculatePosition(stream.getCanvasSize());

    // 7. ì˜ì†í™”
    await this.commentRepository.save(comment);

    // 8. ìºì‹œ ì—…ë°ì´íŠ¸
    await this.cacheComment(comment);

    // 9. í†µê³„ ì—…ë°ì´íŠ¸
    await this.updateStatistics(dto.streamId);

    return comment;
  }

  private async checkRateLimit(userId: string, streamId: string): Promise<boolean> {
    const key = `rate:comment:${userId}:${streamId}`;
    const count = await this.redis.incr(key);
    
    if (count === 1) {
      await this.redis.expire(key, 60); // 60ì´ˆ
    }
    
    return count <= 30; // ë¶„ë‹¹ 30ê°œ ì œí•œ
  }

  private async cacheComment(comment: Comment): Promise<void> {
    const key = `stream:${comment.streamId}:comments`;
    await this.redis.lpush(key, JSON.stringify(comment.toDTO()));
    await this.redis.ltrim(key, 0, 99); // ìµœê·¼ 100ê°œë§Œ ìœ ì§€
  }

  private async updateStatistics(streamId: string): Promise<void> {
    await this.redis.hincrby(`stream:${streamId}:stats`, 'comments', 1);
  }

  async addViewer(streamId: string, userId: string): Promise<number> {
    const key = `stream:${streamId}:viewers`;
    await this.redis.sadd(key, userId);
    return await this.redis.scard(key);
  }

  async removeViewer(streamId: string, userId: string): Promise<number> {
    const key = `stream:${streamId}:viewers`;
    await this.redis.srem(key, userId);
    return await this.redis.scard(key);
  }

  async handleDisconnect(clientId: string): Promise<void> {
    // í´ë¼ì´ì–¸íŠ¸ ì •ë¦¬ ë¡œì§
  }
}
```

```typescript
// application/usecases/SendCommentUseCase.ts
import { Injectable } from '@nestjs/common';
import { Comment } from '@/domain/entities/Comment';
import { Stream } from '@/domain/entities/Stream';

@Injectable()
export class SendCommentUseCase {
  constructor(
    private readonly streamRepo: IStreamRepository,
    private readonly commentRepo: ICommentRepository,
    private readonly eventBus: EventBus,
  ) {}

  async execute(params: {
    text: string;
    command?: string;
    streamId: string;
    userId: string;
  }): Promise<Comment> {
    // íŠ¸ëœì­ì…˜ ì‹œì‘
    return await this.transactionManager.run(async () => {
      // 1. ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ ë° ê²€ì¦
      const stream = await this.streamRepo.findById(params.streamId);
      if (!stream.canReceiveComments()) {
        throw new Error('Comments are disabled');
      }

      // 2. ëŒ“ê¸€ ìƒì„±
      const comment = stream.addComment({
        text: params.text,
        userId: params.userId,
        command: params.command,
      });

      // 3. ì €ì¥
      await this.commentRepo.save(comment);
      await this.streamRepo.save(stream);

      // 4. ì´ë²¤íŠ¸ ë°œí–‰
      await this.eventBus.publish(new CommentCreatedEvent(comment));

      return comment;
    });
  }
}
```

### 3. Domain Layer (ë„ë©”ì¸ ê³„ì¸µ)
> **ì±…ì„**: í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§, ë„ë©”ì¸ ëª¨ë¸, ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- Entities (ì—”í‹°í‹°)
- Value Objects (ê°’ ê°ì²´)
- Domain Services (ë„ë©”ì¸ ì„œë¹„ìŠ¤)
- Domain Events (ë„ë©”ì¸ ì´ë²¤íŠ¸)

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
backend/src/domain/
â”œâ”€â”€ entities/          # ì—”í‹°í‹°
â”‚   â”œâ”€â”€ User.ts
â”‚   â”œâ”€â”€ Stream.ts
â”‚   â”œâ”€â”€ Comment.ts
â”‚   â””â”€â”€ Room.ts
â”œâ”€â”€ valueObjects/      # ê°’ ê°ì²´
â”‚   â”œâ”€â”€ UserId.ts
â”‚   â”œâ”€â”€ StreamId.ts
â”‚   â”œâ”€â”€ CommentStyle.ts
â”‚   â””â”€â”€ CommentPosition.ts
â”œâ”€â”€ services/          # ë„ë©”ì¸ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ LaneManager.ts
â”‚   â”œâ”€â”€ CommentValidator.ts
â”‚   â”œâ”€â”€ CommentFilter.ts
â”‚   â””â”€â”€ CollisionDetector.ts
â”œâ”€â”€ events/           # ë„ë©”ì¸ ì´ë²¤íŠ¸
â”‚   â”œâ”€â”€ CommentCreated.ts
â”‚   â”œâ”€â”€ StreamStarted.ts
â”‚   â””â”€â”€ UserJoined.ts
â””â”€â”€ specifications/   # ëª…ì„¸ íŒ¨í„´
    â”œâ”€â”€ ActiveStreamSpec.ts
    â””â”€â”€ ValidCommentSpec.ts
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// domain/entities/Stream.ts
import { AggregateRoot } from '@/domain/base/AggregateRoot';
import { StreamId } from '../valueObjects/StreamId';
import { UserId } from '../valueObjects/UserId';
import { Comment } from './Comment';
import { StreamStartedEvent } from '../events/StreamStarted';

export class Stream extends AggregateRoot {
  private readonly id: StreamId;
  private readonly ownerId: UserId;
  private title: string;
  private description: string;
  private status: StreamStatus;
  private viewerCount: number;
  private readonly comments: Comment[];
  private readonly settings: StreamSettings;
  private startedAt?: Date;
  private endedAt?: Date;

  constructor(params: {
    id?: StreamId;
    ownerId: UserId;
    title: string;
    description?: string;
  }) {
    super();
    this.id = params.id || StreamId.generate();
    this.ownerId = params.ownerId;
    this.title = params.title;
    this.description = params.description || '';
    this.status = StreamStatus.WAITING;
    this.viewerCount = 0;
    this.comments = [];
    this.settings = new StreamSettings();
  }

  // ë¹„ì¦ˆë‹ˆìŠ¤ ë©”ì„œë“œ
  public start(): void {
    if (this.status !== StreamStatus.WAITING) {
      throw new Error('Stream can only be started from waiting status');
    }
    
    this.status = StreamStatus.LIVE;
    this.startedAt = new Date();
    
    // ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œìƒ
    this.addDomainEvent(new StreamStartedEvent(this.id, this.ownerId));
  }

  public end(): void {
    if (this.status !== StreamStatus.LIVE) {
      throw new Error('Only live streams can be ended');
    }
    
    this.status = StreamStatus.ENDED;
    this.endedAt = new Date();
  }

  public addComment(params: {
    text: string;
    userId: string;
    command?: string;
  }): Comment {
    if (!this.canReceiveComments()) {
      throw new Error('Stream cannot receive comments');
    }

    const comment = new Comment({
      streamId: this.id,
      userId: params.userId,
      text: params.text,
      command: params.command,
    });

    // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ì ìš©
    if (this.settings.requireModeration) {
      comment.markForModeration();
    }

    this.comments.push(comment);
    return comment;
  }

  public canReceiveComments(): boolean {
    return this.status === StreamStatus.LIVE && 
           this.settings.allowComments;
  }

  public isLive(): boolean {
    return this.status === StreamStatus.LIVE;
  }

  public isOwnedBy(userId: UserId): boolean {
    return this.ownerId.equals(userId);
  }

  public incrementViewers(): void {
    this.viewerCount++;
  }

  public decrementViewers(): void {
    if (this.viewerCount > 0) {
      this.viewerCount--;
    }
  }

  public getCanvasSize(): { width: number; height: number } {
    return {
      width: this.settings.canvasWidth,
      height: this.settings.canvasHeight,
    };
  }

  public toDTO() {
    return {
      id: this.id.value,
      ownerId: this.ownerId.value,
      title: this.title,
      description: this.description,
      status: this.status,
      viewerCount: this.viewerCount,
      settings: this.settings.toDTO(),
      startedAt: this.startedAt,
      endedAt: this.endedAt,
    };
  }
}

enum StreamStatus {
  WAITING = 'waiting',
  LIVE = 'live',
  ENDED = 'ended',
}

class StreamSettings {
  public allowComments: boolean = true;
  public requireModeration: boolean = false;
  public commentCooldown: number = 1000;
  public maxViewers: number = 1000;
  public canvasWidth: number = 1280;
  public canvasHeight: number = 720;

  toDTO() {
    return { ...this };
  }
}
```

```typescript
// domain/services/LaneManager.ts
import { Injectable } from '@nestjs/common';
import { Comment } from '../entities/Comment';
import { Lane } from '../valueObjects/Lane';

@Injectable()
export class LaneManager {
  private readonly lanes: Map<string, Lane[]> = new Map();
  private readonly laneCount = 12;
  private readonly laneHeight = 30;

  public assignLane(comment: Comment): number {
    const streamId = comment.streamId.value;
    
    if (!this.lanes.has(streamId)) {
      this.initializeLanes(streamId);
    }

    const streamLanes = this.lanes.get(streamId)!;
    
    // ë„ë©”ì¸ ê·œì¹™: ëŒ“ê¸€ íƒ€ì…ë³„ ë ˆì¸ í• ë‹¹
    if (comment.isFixed()) {
      return this.getFixedLane(comment);
    }

    // ì¶©ëŒ ì—†ëŠ” ë ˆì¸ ì°¾ê¸°
    for (let i = 0; i < this.laneCount; i++) {
      const lane = streamLanes[i];
      if (!lane.hasCollision(comment)) {
        lane.addComment(comment);
        return i;
      }
    }

    // ê°€ì¥ ì—¬ìœ ìˆëŠ” ë ˆì¸ ì„ íƒ
    return this.findLeastCrowdedLane(streamLanes);
  }

  private initializeLanes(streamId: string): void {
    const lanes: Lane[] = [];
    for (let i = 0; i < this.laneCount; i++) {
      lanes.push(new Lane(i, this.laneHeight));
    }
    this.lanes.set(streamId, lanes);
  }

  private getFixedLane(comment: Comment): number {
    switch (comment.style.position) {
      case 'top':
        return 0;
      case 'bottom':
        return this.laneCount - 1;
      default:
        return Math.floor(this.laneCount / 2);
    }
  }

  private findLeastCrowdedLane(lanes: Lane[]): number {
    let minCount = Infinity;
    let bestLane = 0;

    lanes.forEach((lane, index) => {
      const count = lane.getCommentCount();
      if (count < minCount) {
        minCount = count;
        bestLane = index;
      }
    });

    return bestLane;
  }

  public clearStreamLanes(streamId: string): void {
    this.lanes.delete(streamId);
  }
}
```

### 4. Infrastructure Layer (ì¸í”„ë¼ ê³„ì¸µ)
> **ì±…ì„**: ê¸°ìˆ ì  êµ¬í˜„, ì™¸ë¶€ ì‹œìŠ¤í…œ í†µí•©, ë°ì´í„° ì˜ì†ì„±

#### í¬í•¨ë˜ëŠ” ì½”ë“œ
- Repository êµ¬í˜„
- ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼
- ì™¸ë¶€ API í´ë¼ì´ì–¸íŠ¸
- ìºì‹œ êµ¬í˜„

#### ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
backend/src/infrastructure/
â”œâ”€â”€ database/          # ë°ì´í„°ë² ì´ìŠ¤
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ UserRepository.ts
â”‚   â”‚   â”œâ”€â”€ StreamRepository.ts
â”‚   â”‚   â””â”€â”€ CommentRepository.ts
â”‚   â”œâ”€â”€ entities/      # TypeORM ì—”í‹°í‹°
â”‚   â”‚   â”œâ”€â”€ UserEntity.ts
â”‚   â”‚   â”œâ”€â”€ StreamEntity.ts
â”‚   â”‚   â””â”€â”€ CommentEntity.ts
â”‚   â””â”€â”€ migrations/
â”œâ”€â”€ redis/            # Redis
â”‚   â”œâ”€â”€ redis.service.ts
â”‚   â””â”€â”€ redis.module.ts
â”œâ”€â”€ websocket/        # WebSocket
â”‚   â””â”€â”€ socket-io.adapter.ts
â””â”€â”€ config/          # ì„¤ì •
    â”œâ”€â”€ database.config.ts
    â””â”€â”€ redis.config.ts
```

#### ì½”ë“œ ì˜ˆì‹œ
```typescript
// infrastructure/database/repositories/StreamRepository.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { StreamEntity } from '../entities/StreamEntity';
import { Stream } from '@/domain/entities/Stream';
import { IStreamRepository } from '@/application/interfaces/IStreamRepository';
import { StreamId } from '@/domain/valueObjects/StreamId';

@Injectable()
export class StreamRepository implements IStreamRepository {
  constructor(
    @InjectRepository(StreamEntity)
    private readonly repository: Repository<StreamEntity>,
  ) {}

  async findById(id: string | StreamId): Promise<Stream | null> {
    const streamId = typeof id === 'string' ? id : id.value;
    const entity = await this.repository.findOne({
      where: { id: streamId },
    });

    if (!entity) {
      return null;
    }

    return this.toDomain(entity);
  }

  async findAll(params: {
    status?: string;
    page: number;
    limit: number;
  }): Promise<Stream[]> {
    const query = this.repository.createQueryBuilder('stream');

    if (params.status) {
      query.where('stream.status = :status', { status: params.status });
    }

    query
      .orderBy('stream.createdAt', 'DESC')
      .skip((params.page - 1) * params.limit)
      .limit(params.limit);

    const entities = await query.getMany();
    return entities.map(e => this.toDomain(e));
  }

  async save(stream: Stream): Promise<void> {
    const entity = this.toEntity(stream);
    await this.repository.save(entity);
  }

  async delete(id: string | StreamId): Promise<void> {
    const streamId = typeof id === 'string' ? id : id.value;
    await this.repository.delete(streamId);
  }

  private toDomain(entity: StreamEntity): Stream {
    // Entityë¥¼ ë„ë©”ì¸ ëª¨ë¸ë¡œ ë³€í™˜
    return Stream.fromPersistence({
      id: new StreamId(entity.id),
      ownerId: new UserId(entity.ownerId),
      title: entity.title,
      description: entity.description,
      status: entity.status,
      viewerCount: entity.viewerCount,
      startedAt: entity.startedAt,
      endedAt: entity.endedAt,
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt,
    });
  }

  private toEntity(stream: Stream): StreamEntity {
    // ë„ë©”ì¸ ëª¨ë¸ì„ Entityë¡œ ë³€í™˜
    const dto = stream.toDTO();
    const entity = new StreamEntity();
    
    entity.id = dto.id;
    entity.ownerId = dto.ownerId;
    entity.title = dto.title;
    entity.description = dto.description;
    entity.status = dto.status;
    entity.viewerCount = dto.viewerCount;
    entity.startedAt = dto.startedAt;
    entity.endedAt = dto.endedAt;
    
    return entity;
  }
}
```

```typescript
// infrastructure/redis/redis.service.ts
import { Injectable } from '@nestjs/common';
import { Redis } from 'ioredis';
import { InjectRedis } from '@liaoliaots/nestjs-redis';

@Injectable()
export class RedisService {
  constructor(@InjectRedis() private readonly redis: Redis) {}

  // ê¸°ë³¸ operations
  async get(key: string): Promise<string | null> {
    return await this.redis.get(key);
  }

  async set(key: string, value: string, ttl?: number): Promise<void> {
    if (ttl) {
      await this.redis.set(key, value, 'EX', ttl);
    } else {
      await this.redis.set(key, value);
    }
  }

  async del(key: string): Promise<void> {
    await this.redis.del(key);
  }

  // Counter operations
  async incr(key: string): Promise<number> {
    return await this.redis.incr(key);
  }

  async decr(key: string): Promise<number> {
    return await this.redis.decr(key);
  }

  async expire(key: string, seconds: number): Promise<void> {
    await this.redis.expire(key, seconds);
  }

  // List operations
  async lpush(key: string, value: string): Promise<number> {
    return await this.redis.lpush(key, value);
  }

  async rpush(key: string, value: string): Promise<number> {
    return await this.redis.rpush(key, value);
  }

  async lrange(key: string, start: number, stop: number): Promise<string[]> {
    return await this.redis.lrange(key, start, stop);
  }

  async ltrim(key: string, start: number, stop: number): Promise<void> {
    await this.redis.ltrim(key, start, stop);
  }

  // Set operations
  async sadd(key: string, member: string): Promise<number> {
    return await this.redis.sadd(key, member);
  }

  async srem(key: string, member: string): Promise<number> {
    return await this.redis.srem(key, member);
  }

  async smembers(key: string): Promise<string[]> {
    return await this.redis.smembers(key);
  }

  async scard(key: string): Promise<number> {
    return await this.redis.scard(key);
  }

  // Hash operations
  async hset(key: string, field: string, value: string): Promise<number> {
    return await this.redis.hset(key, field, value);
  }

  async hget(key: string, field: string): Promise<string | null> {
    return await this.redis.hget(key, field);
  }

  async hgetall(key: string): Promise<Record<string, string>> {
    return await this.redis.hgetall(key);
  }

  async hincrby(key: string, field: string, increment: number): Promise<number> {
    return await this.redis.hincrby(key, field, increment);
  }
}
```

---

## ğŸ”„ ë ˆì´ì–´ ê°„ í†µì‹ 

### ì˜ì¡´ì„± ë°©í–¥
```
Presentation â†’ Application â†’ Domain â† Infrastructure
```

### ë°ì´í„° íë¦„ ì˜ˆì‹œ

#### ëŒ“ê¸€ ì „ì†¡ í”Œë¡œìš°
```
1. Presentation Layer
   - CommentGatewayê°€ WebSocket ë©”ì‹œì§€ ìˆ˜ì‹ 
   - SendCommentDto ìœ íš¨ì„± ê²€ì¦
   â†“
2. Application Layer
   - CommentService.processComment() í˜¸ì¶œ
   - Rate limiting ì²´í¬
   - íŠ¸ëœì­ì…˜ ê´€ë¦¬
   â†“
3. Domain Layer
   - Comment ì—”í‹°í‹° ìƒì„±
   - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ì ìš©
   - LaneManagerë¡œ ë ˆì¸ í• ë‹¹
   â†“
4. Infrastructure Layer
   - PostgreSQLì— ì €ì¥
   - Redis ìºì‹œ ì—…ë°ì´íŠ¸
   â†“
5. Application Layer
   - ì´ë²¤íŠ¸ ë°œí–‰
   â†“
6. Presentation Layer
   - WebSocketìœ¼ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
```

---

## ğŸ“ ì „ì²´ í”„ë¡œì íŠ¸ êµ¬ì¡°

```
project/
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/      # Presentation Layer
â”‚   â”‚   â”œâ”€â”€ layouts/
â”‚   â”‚   â”œâ”€â”€ hooks/           # Application Layer
â”‚   â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ domain/          # Domain Layer
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ valueObjects/
â”‚   â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚   â””â”€â”€ infrastructure/  # Infrastructure Layer
â”‚   â”‚       â”œâ”€â”€ api/
â”‚   â”‚       â”œâ”€â”€ websocket/
â”‚   â”‚       â””â”€â”€ storage/
â”‚   â””â”€â”€ package.json
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ controllers/     # Presentation Layer
â”‚   â”‚   â”œâ”€â”€ gateways/
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”œâ”€â”€ application/     # Application Layer
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ usecases/
â”‚   â”‚   â”œâ”€â”€ domain/          # Domain Layer
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”œâ”€â”€ valueObjects/
â”‚   â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚   â””â”€â”€ infrastructure/  # Infrastructure Layer
â”‚   â”‚       â”œâ”€â”€ database/
â”‚   â”‚       â”œâ”€â”€ redis/
â”‚   â”‚       â””â”€â”€ config/
â”‚   â””â”€â”€ package.json
â”‚
â””â”€â”€ docker-compose.yml
```

---

## âœ… ë ˆì´ì–´ë³„ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Presentation Layer
- [ ] UIì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë¶„ë¦¬
- [ ] DTO ìœ íš¨ì„± ê²€ì¦
- [ ] ì—ëŸ¬ ë©”ì‹œì§€ í¬ë§·íŒ…
- [ ] ìš”ì²­/ì‘ë‹µ ë³€í™˜

### Application Layer
- [ ] ìœ ì¦ˆì¼€ì´ìŠ¤ êµ¬í˜„
- [ ] íŠ¸ëœì­ì…˜ ê²½ê³„ ì„¤ì •
- [ ] ì›Œí¬í”Œë¡œìš° ì¡°ì •
- [ ] ì´ë²¤íŠ¸ ë°œí–‰

### Domain Layer
- [ ] ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ìº¡ìŠí™”
- [ ] ë„ë©”ì¸ ëª¨ë¸ ë¬´ê²°ì„±
- [ ] ì™¸ë¶€ ì˜ì¡´ì„± ì—†ìŒ
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥

### Infrastructure Layer
- [ ] ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
- [ ] ì™¸ë¶€ ì‹œìŠ¤í…œ í†µí•©
- [ ] ê¸°ìˆ ì  ì„¸ë¶€ì‚¬í•­ ìˆ¨ê¹€
- [ ] êµì²´ ê°€ëŠ¥í•œ êµ¬í˜„

---

## ğŸ¯ í•µì‹¬ ì´ì 

1. **ìœ ì§€ë³´ìˆ˜ì„±**: ê° ë ˆì´ì–´ê°€ ë…ë¦½ì ìœ¼ë¡œ ìˆ˜ì • ê°€ëŠ¥
2. **í…ŒìŠ¤íŠ¸ ìš©ì´ì„±**: ë ˆì´ì–´ë³„ ë…ë¦½ì  í…ŒìŠ¤íŠ¸
3. **í™•ì¥ì„±**: ë ˆì´ì–´ë³„ ë…ë¦½ì  í™•ì¥
4. **ì¬ì‚¬ìš©ì„±**: ë„ë©”ì¸ ë¡œì§ ì¬ì‚¬ìš©
5. **ëª…í™•í•œ ì±…ì„**: ê° ë ˆì´ì–´ì˜ ì—­í• ì´ ëª…í™•

ì´ ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ëŠ” ì½”ë“œì˜ êµ¬ì¡°í™”ì™€ ìœ ì§€ë³´ìˆ˜ë¥¼ í¬ê²Œ ê°œì„ í•©ë‹ˆë‹¤.